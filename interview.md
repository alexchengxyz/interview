# 面試考題

## JavaScript

### 什麼是作用域 (scope)？

1. 變數在程式中可以被存取的範圍。
1. 可分為區域變數，全域變數。
1. 它是用函式(Function)作為區分，在函式內為區域變數，函式外為全域變數。
1. 分三個層級: Global Level Scope、Function Level Scope、Block Level Scope
1. 在函式中用 const 或 let 宣告變數，都會立即讓這個變數在函式中擁有 Block Level Scope。

### 什麼是 hoisting？

會先把宣告的變數和函式放在程式的頂端，等到實際執行時在賦予其值。(這邊注意提升是邏輯上的概念，並非實際將程式移動到頂端)

### 淺拷貝V.S深拷貝

1. 淺拷貝就是共用同一個記憶體空間，例如更改拷貝的object會影響原來的Object。
2. 深拷貝則是兩個不同的記憶體空間，例如更改拷貝的object後不會影響原來的Object。

### 閉包是什麼?

1. 閉包(Closure)是資料結構的一種。當一個函式被宣告時，函式對其周圍狀態(詞法環境，lexical environment)的引用在一起(也可以想成函式記住了宣告時的作用域環境)，這樣的組合就是閉包。
1. 閉包可以讓函式內部的變數不受外部環境的影響。
1. 而閉包內部可以透過作用域鏈獲取外部資料。

### 閉包的特性

1. 當一個函式內部回傳了另一個函式，便是有用到閉包的概念。
2. 閉包可以讓函式內部的變數不受外部環境的影響。
3. 而閉包內部可以透過作用域鏈獲取外部資料。

### 要如何用閉包?

1. 可以把程式中需要重複執行的部分透過閉包封裝起來，進一步簡化程式。
1. 可以將變數私有化，減少全域環境的命名衝突
1. 閉包也可以將內部函式開放給外部使用。
1. 閉包的結構屬於高消費的語法，使用不當會影響程式效能，大多數情況，不需要擔心這方面的問題，因為JavaScript引擎有很好的記憶體回收機制。

### 同步(Sync)與非同步(Async)

1. Javascript 是一種「單執行續 」的語言。
1. 一次只做一件事情。
1. 同時可以做很多件事情，不需要等到前一件事情做完才做下一件事情。
1. 在瀏覽器內，只有 Javascript 引擎本身是同步的，而 Javascript 引擎可以跟 WebAPI 溝通，達到非同步的事件處理。

### 什麼是遞迴?

遞迴就是運用函數可以呼叫函數本身並搭配邊界條件(終止條件)，來達到可以簡化迴圈的效果。

### 簡單說明 Promise？

Promise 物件代表一個即將完成、或失敗的非同步操作，以及它所產生的值。

### Promise 與 Async、Await 有什麼關係？

Promise 是用來優化非同步的語法，而 Async、Await 可以基於 Promise 讓非同步的語法的結構類似於 “同步語言”，更易讀且好管理。

### HTTP 狀態碼 304 代表什麼？是多好還是少好？

表示“未修改”。當客戶端請求一個已快取的資源時，服務器可以返回 304 狀態碼，以告訴客戶端資源未被修改過，可以直接使用快取。這可減少服務器和客戶端之間的數據傳輸，提高性能和減少帶寬使用。

### 什麼是Event Bubbling 事件冒泡

事件冒泡是指在 HTML DOM 中，當某個元素觸發了某個事件，這個事件會向上冒泡到所有的原始元素。換句話說，當一個元素觸發了某個事件時，該事件不僅會作用於該元素本身，還會作用於它的所有原始元素。

### typescript any vs. unknown 的差別

1. any 表示任意類型，可以在編譯時和運行時通過任何方法調用和訪問任何屬性
1. unknown 表示未知類型，與 any 類型相似，但具有更嚴格的類型檢查和限制。

### document.ready和window.onload的區別?

1. ready: 文檔結構已經加載完成（不含圖片等非文字媒體文件），ready事件在DOM結構繪製完成之後就會執行，這樣能確保就算有大量的媒體文件沒加載出來，JS代碼一樣可以執行。
1. onload，指示頁面含圖片等文件在內的所有元素都加載完成，必須等到網頁中所有內容全部加載完畢之後才被執行。如果一個網頁中有大量的圖片的話，則就會出現這種情況：網頁文檔已經呈現出來，但由於網頁數據還沒有完全加載完畢，導致load事件不能夠即時被觸發。

### 輸入網址到載入網頁後，通常會經歷以下幾個步驟：

 1. DNS 解析：將網址轉換為IP地址，這個過程被稱為 DNS 解析。當您輸入網址時，您的瀏覽器會向 DNS 伺服器發送請求，以查找與該網址相關的IP地址。
 2. 建立 TCP 連接：瀏覽器已經知道了網頁的IP地址，它會試圖與Web服務器建立TCP連接，可確保在數據傳輸過程中不會丟失數據。
 3. 發送 HTTP 請求：建立了TCP連接，瀏覽器將發送HTTP請求到Web服務器。
 4. 伺服器處理請求：接收到請求後，將根據請求的內容返回網頁的相應內容。
 5. 瀏覽器渲染網頁：一旦瀏覽器收到了網頁的內容，它將使用HTML、CSS和JavaScript等技術將網頁呈現給您。

### Js 箭頭含式優點

1. 簡潔：箭頭函式可以更簡潔地定義函式，通常可以用一行代碼來取代多行傳統函式的定義方式，這使得程式碼更簡潔易讀。
2. 無需綁定this：箭頭函式沒有自己的this，它會使用其外部函式的this值，因此可以避免由於this的作用域而導致的錯誤。
3. 更少的代碼：使用箭頭函式可以簡化回調函式的定義，特別是對於一些只有一行代碼的函式。

### ready與load誰先執行？

ready先執行。

### 前端工程師設計準則

1. 以使用者體驗為先。
1. 介面要簡潔明瞭。
1. 保持一致性，如使用相同的佈局、顏色和字體等元素。
1. 確保網站或應用程式對所有人都可訪問。
1. 實現響應式設計。
1. 導航要清晰。
1. 優化網站或應用程式的性能。
1. 保護使用者的數據和隱私。

### 如何處理跨域請求?

1. JSONP：使用 JSONP 技術可以實現跨域請求，它的原理是通過在網頁中動態添加一個 script 標籤，並在 URL 的 query string 中傳遞一個 callback 函數名，伺服器端將數據包裝成函數調用的形式返回，前端通過 callback 函數處理返回的數據。
1. CORS：CORS 是一種跨域請求的標準，它利用 HTTP header 傳遞信任信息，實現瀏覽器對伺服器的跨域請求進行授權。需要在伺服器端進行相應的配置，允許來自其他域名的跨域請求。
1. 代理：在前端應用中設置一個代理伺服器，將前端發起的請求轉發到伺服器端，再將伺服器端的響應返回給前端，因為是同源的請求，因此不會出現跨域問題。
1. iframe：使用 iframe 能夠在同一個網頁中展示不同源的內容，因此也可以利用 iframe 實現跨域請求。

### 簡易說明 JavaScript 原型和原型鏈

在 JavaScript 中，所有的物件都有一個原型，原型是一個物件，物件可以通過它來繼承方法和屬性。每個物件都有一個 Prototype 的內部屬性，指向它的原型物件。
JavaScript 原型和原型鏈是實現繼承的重要機制，通過原型鏈，物件可以共享原型的方法和屬性，達到節省記憶體和提高效率的目的。

### localstorage sessionstorage cookie 區別

- LocalStorage: 同一個網域名下的所有網頁都可以訪問，無過期時間，只有通過編程或者用戶手動清除才會被刪除。主要用於存儲用戶長期保存的數據，例如設置、偏好等。
- SessionStorage：和 LocalStorage 類似，同樣是 HTML5 中新增的 API，它存儲的數據在當前會話窗口中有效，即在當前瀏覽器窗口關閉時就會被清除。主要用於存儲用戶會話期間需要保存的數據，例如登錄信息、購物車等。
- Cookie: 是 HTTP 協議中的一種機制，它可以在瀏覽器和服務器之間進行數據傳輸，Cookie 有一個過期時間，可以通過設置過期時間來控制 Cookie 的有效期。Cookie 主要用於存儲需要在不同頁面之間共享的數據，例如用戶的身份驗證信息。

### cookie 和 session 差異

1. 存儲位置: Cookie 資料是存儲在用戶端的，而 Session 資料是存儲在服務端的。
2. 資料類型: Cookie 只能存字符串類型的資料，而 Session 可以存各種類型的資料。
3. 存儲容量：Cookie 的存儲容量比較小，一般只能存儲 KB 的資料，而 Session 的存儲容量比較大，一般可以存數 MB 的資料。
4. 過期時間：Cookie 可以通過設置過期時間來控制 Cookie 的有效期，而 Session 的有效期是在服務端設置的，一般是在瀏覽器關閉時失效。
5. 安全性：Cookie 的安全性較低，容易被攻擊者竊取和修改，而 Session 的安全性較高，因為資料都存在服務端。

## React

### React 生命週期

Mount -> Update -> Unmount

- Mount 創建: 元件被渲染到畫面上。
- Update 更新: 元件的內容因為資料的更動而重新渲染。
- Unmount 銷毀: 件從畫面上消失，移除這個元件。

Mount
1. constructor：初始化狀態和綁定方法。
1. getDerivedStateFromProps：接收新的 props 後更新狀態。
1. render：渲染組件。
1. componentDidMount：當組件被渲染到 DOM 中時觸發。

Update
1. getDerivedStateFromProps：接收新的 props 後更新狀態。
1. shouldComponentUpdate：決定是否需要重新渲染組件。
1. render：渲染組件。
1. getSnapshotBeforeUpdate：在更新前獲取 DOM 狀態。
1. componentDidUpdate：在更新後觸發，通常用於獲取新的 props 或更新 DOM。

Unmount
componentWillUnmount：在組件卸載之前觸發，用於清除定時器或取消請求等操作。

- useState：用於在組件中添加狀態，取代了類組件中的 constructor 和 setState 方法。
- useEffect：用於在組件中執行副作用，取代了類組件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 方法。

### useMemo 是什麼？有什麼特性
用於優化性能，當需要根據某些數據計算出一個新的值時，如果每次渲染都重新計算這個值，會對應用的性能造成一定的影響。useMemo 可以快取計算結果，避免重複計算，從而提高應用的性能。

1. 接受一個計算函數和一個依賴陣列作為參數，計算函數表示需要快取的計算邏輯，依賴數組表示計算函數依賴的狀態數據。
1. 會返回一個快取的值，這個值只有在依賴陣列中的狀態數據發生改變時才會重新計算。
1. 主要作用是優化計算的性能，避免重複計算和渲染。
1. 可以用於優化子級元件的性能，避免子級元件的重新渲染對應用性能造成影響。
1. 只能用於快取值，不能用於緩存函數等其他數據類型。

### memo 是什麼？有什麼特性
當一個函數式元件被包裹在 React Memo 中時，React 會進行一次淺層比較檢查該元件的屬性（props）。  
如果這些屬性自上次渲染以來沒有變化，React 會重用之前渲染的結果，避免重新渲染該元件。這樣可以大幅提升 React 應用程式的效能，避免在輸入沒有變化的情況下進行不必要的重新渲染。

### useCallback 是什麼？有什麼特性

當父級元件的狀態更新時，子級元件會重新渲染，如果子級元件中包含一些函數，每次重新渲染都會導致函數的重新定義和創建，這會對性能造成一定的影響。useCallback 可以緩存函數，避免函數的重新定義和創建，從而提高應用的性能。

1. 接受一個函數和一個依賴陣列作為參數，函數表示需要快取的函數，依陣列組表示函數依賴的狀態數據。
1. 會返回一個快取的函數，這個函數只有在依賴陣列中的狀態數據發生改變時才會重新創建。
1. 的主要作用是優化函數的性能，避免函數的重複創建和定義，從而提高應用的性能。
1. 可以用於優化子級元件的性能，避免子級元件的重新渲染對應用性能造成影響。
1. 只能用於緩存函數，不能用於快取物件等其他數據類型。

## CSS

### 如何用長寬 200px div 垂直置中?

```html
<div class="container">
  <div class="box"></div>
</div>
```

```css
.container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh; /* 這會將 container 高度設定為螢幕的整個高度 */
}

.box {
  width: 200px;
  height: 200px;
}
```

### position 有什麼特性

1. static（預設值）：元素的位置由頁面的正常流程決定，不受到top、right、bottom、left或z-index屬性的影響。
1. relative：元素的位置會相對於其在正常流程中的位置進行偏移。
1. absolute：元素會相對於最近的已定位祖先元素（即，已設置為relative、absolute、fixed或sticky的元素）進行定位。
1. fixed：元素會相對於視窗進行定位，並且不會隨著頁面的捲動而移動。
1. sticky：元素在超過指定偏移量之前會保持其正常流程中的位置，之後會相對於其最近的已定位祖先元素（即，已設置為relative、absolute、fixed或sticky的元素）進行定位。

### css 權重優先順序

!important > inline style > ID > Class/psuedo-class(偽類)/attribute（屬性選擇器） > Element

### 給div 如何置中 幾種方式
```css
.center {
  width: 50%; /* 假設 div 寬度為 50% */
  margin: 0 auto;
}

.container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh; /* 假設要將 div 置中於視窗垂直方向 */
}

.center {
  /* 可以不指定寬度 */
}

.container {
  display: grid;
  place-items: center;
  height: 100vh; /* 假設要將 div 置中於視窗垂直方向 */
}

.center {
  /* 可以不指定寬度 */
}
```

